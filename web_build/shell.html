<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helbreath Raylib</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        canvas.emscripten {
            border: 0;
            background-color: black;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            pointer-events: auto;
            cursor: none;
            outline: none;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        #progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            max-width: 500px;
            z-index: 100;
        }

        #progress {
            width: 100%;
            height: 30px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }

        #progress-text {
            color: white;
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex="0" width="1024" height="768"></canvas>
    </div>

    <div id="status">Downloading...</div>

    <div id="progress-container">
        <div id="progress">
            <div id="progress-bar"></div>
        </div>
        <div id="progress-text">Loading assets...</div>
    </div>

    <script type='text/javascript'>
        var statusElement = document.getElementById('status');
        var progressContainer = document.getElementById('progress-container');
        var progressBar = document.getElementById('progress-bar');
        var progressText = document.getElementById('progress-text');

        var Module = {
            preRun: [],
            postRun: [],
            print: (function() {
                return function(text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                    console.log(text);
                };
            })(),
            printErr: function(text) {
                if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                console.error(text);
            },
            canvas: (function() {
                var canvas = document.getElementById('canvas');

                // Ensure canvas can receive focus
                canvas.setAttribute('tabindex', '0');

                // Focus canvas immediately and on any user interaction
                canvas.focus();

                // Aggressive focus management
                var focusCanvas = function() {
                    canvas.focus();
                };

                document.addEventListener('click', focusCanvas, false);
                document.addEventListener('touchstart', focusCanvas, false);
                document.addEventListener('mousedown', focusCanvas, false);
                canvas.addEventListener('mouseenter', focusCanvas, false);
                
                canvas.addEventListener("webglcontextlost", function(e) {
                    alert('WebGL context lost. You will need to reload the page.');
                    e.preventDefault();
                }, false);
                
                
                // For point-and-click games, just track if canvas has focus
                var isGameActive = false;

                canvas.addEventListener('mouseenter', function() {
                    isGameActive = true;
                    console.log('[Input] Mouse entered canvas - isGameActive = true');
                }, false);

                canvas.addEventListener('mouseleave', function() {
                    isGameActive = false;
                    console.log('[Input] Mouse left canvas - isGameActive = false');
                }, false);

                // Debug: Log mouse clicks on canvas
                canvas.addEventListener('mousedown', function(e) {
                    console.log('[Input] Canvas mousedown:', e.button, 'at', e.clientX, e.clientY);
                }, false);

                canvas.addEventListener('click', function(e) {
                    console.log('[Input] Canvas click:', e.button, 'at', e.clientX, e.clientY);
                }, false);
                
                // Prevent ALL clicks outside canvas when game is active
                document.addEventListener('mousedown', function(e) {
                    if (isGameActive && e.target !== canvas) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }
                }, true);
                
                document.addEventListener('mouseup', function(e) {
                    if (isGameActive && e.target !== canvas) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }
                }, true);
                
                document.addEventListener('click', function(e) {
                    if (isGameActive && e.target !== canvas) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }
                }, true);
                
                // Prevent context menu on right-click
                canvas.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    return false;
                }, false);
                
                // Block ALL browser shortcuts and function keys when mouse is over game
                document.addEventListener('keydown', function(e) {
                    if (isGameActive) {
                        // Block ALL function keys (F1-F12)
                        if (e.key.startsWith('F') && e.key.length <= 3) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                        
                        // Block ALL Ctrl combinations
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                        
                        // Block Alt combinations (except Alt+Tab which browser won't let us block)
                        if (e.altKey && e.key !== 'Tab') {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }, true);
                
                // Additional keydown blocking at window level (capture phase)
                window.addEventListener('keydown', function(e) {
                    if (isGameActive) {
                        // Specifically block Ctrl+T and Ctrl+N which are very protected
                        if ((e.ctrlKey || e.metaKey) && 
                            (e.key === 't' || e.key === 'T' || 
                             e.key === 'n' || e.key === 'N' ||
                             e.key === 'w' || e.key === 'W')) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                        // Block all other Ctrl combinations
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                    }
                }, true);
                
                // Ultra-aggressive blocking on canvas itself
                canvas.addEventListener('keydown', function(e) {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        return false;
                    }
                }, true);
                
                // Block beforeunload when game is active to prevent Ctrl+W
                window.addEventListener('beforeunload', function(e) {
                    if (isGameActive) {
                        e.preventDefault();
                        e.returnValue = '';
                        return '';
                    }
                });
                
                return canvas;
            })(),
            setStatus: function(text) {
                if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
                if (text === Module.setStatus.last.text) return;
                var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/  (\d+)\)/);
                var now = Date.now();
                if (m && now - Module.setStatus.last.time < 30) return;
                Module.setStatus.last.time = now;
                Module.setStatus.last.text = text;

                if (m) {
                    text = m[1];
                    var loaded = parseInt(m[2]);
                    var total = parseInt(m[4]);
                    var percent = (loaded / total * 100).toFixed(0);
                    progressBar.style.width = percent + '%';
                    progressText.innerHTML = text + ' (' + percent + '%)';
                } else {
                    progressBar.style.width = '0%';
                    progressText.innerHTML = text;
                }

                statusElement.innerHTML = text;
            },
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
            }
        };

        // Add data file loading progress and error handling
        Module.dataFileDownloads = {};
        Module.expectedDataFileDownloads = 0;
        
        Module.setStatus('Downloading...');

        // Better error handling for loading failures
        window.onerror = function(event, source, lineno, colno, error) {
            console.error('Error:', event, 'at', source, lineno + ':' + colno);
            Module.setStatus('Exception thrown, see JavaScript console');
            statusElement.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
            Module.setStatus = function(text) {
                if (text) console.error('[post-exception status] ' + text);
            };
        };
        
        // Handle fetch/download errors with retry logic
        Module.locateFile = function(path, prefix) {
            var url = prefix + path;
            if (path.endsWith('.data')) {
                console.log('Loading data file:', url, '(~462MB, may take time)');
            }
            return url;
        };
        
        // Add fetch with timeout and retry
        var originalFetch = window.fetch;
        window.fetchAttempts = {};
        window.fetch = function(url, options) {
            var maxRetries = 3;
            var timeout = 120000; // 2 minutes per attempt
            
            if (!window.fetchAttempts[url]) {
                window.fetchAttempts[url] = 0;
            }
            
            return Promise.race([
                originalFetch(url, options),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Download timeout')), timeout)
                )
            ]).catch(function(err) {
                window.fetchAttempts[url]++;
                console.error('Fetch failed for', url, '(attempt', window.fetchAttempts[url], '/', maxRetries + '):', err);
                
                if (window.fetchAttempts[url] <= maxRetries) {
                    console.log('Retrying download...');
                    Module.setStatus('Retrying download (attempt ' + window.fetchAttempts[url] + ')...');
                    return window.fetch(url, options);
                } else {
                    Module.setStatus('Download failed after ' + maxRetries + ' attempts. Please refresh the page.');
                    statusElement.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                    throw err;
                }
            });
        };

        // Hide loading UI when game starts
        Module.postRun.push(function() {
            setTimeout(function() {
                statusElement.classList.add('hidden');
                progressContainer.classList.add('hidden');
            }, 1000);
        });
    </script>
    {{{ SCRIPT }}}
</body>
</html>